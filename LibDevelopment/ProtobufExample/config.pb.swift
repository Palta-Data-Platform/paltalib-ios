// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ContextApplication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appID: String = String()

  public var appVersion: String = String()

  public var appPlatform: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ContextDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceBrand: String = String()

  public var deviceModel: String = String()

  public var deviceCarrier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Context {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var application: ContextApplication {
    get {return _application ?? ContextApplication()}
    set {_application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  public var hasApplication: Bool {return self._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  public mutating func clearApplication() {self._application = nil}

  public var device: ContextDevice {
    get {return _device ?? ContextDevice()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _application: ContextApplication? = nil
  fileprivate var _device: ContextDevice? = nil
}

public struct EventHeaderPora {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var designID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pora: EventHeaderPora {
    get {return _pora ?? EventHeaderPora()}
    set {_pora = newValue}
  }
  /// Returns true if `pora` has been explicitly set.
  public var hasPora: Bool {return self._pora != nil}
  /// Clears the value of `pora`. Subsequent reads from it will return its default value.
  public mutating func clearPora() {self._pora = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pora: EventHeaderPora? = nil
}

public struct EventPayloadPageOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pageID: String = String()

 
    public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventPayloadStarPress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rate: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventPayloadScanProcessingStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventCommon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventType: Int64 = 0

  public var eventTs: Int64 = 0

  public var sessionID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventType: EventPayload.OneOf_EventType? = nil

  public var event1: EventPayloadPageOpen {
    get {
      if case .event1(let v)? = eventType {return v}
      return EventPayloadPageOpen()
    }
    set {eventType = .event1(newValue)}
  }

  public var event2: EventPayloadStarPress {
    get {
      if case .event2(let v)? = eventType {return v}
      return EventPayloadStarPress()
    }
    set {eventType = .event2(newValue)}
  }

  public var event4: EventPayloadScanProcessingStarted {
    get {
      if case .event4(let v)? = eventType {return v}
      return EventPayloadScanProcessingStarted()
    }
    set {eventType = .event4(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_EventType: Equatable {
    case event1(EventPayloadPageOpen)
    case event2(EventPayloadStarPress)
    case event4(EventPayloadScanProcessingStarted)

  #if !swift(>=4.1)
    public static func ==(lhs: EventPayload.OneOf_EventType, rhs: EventPayload.OneOf_EventType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.event1, .event1): return {
        guard case .event1(let l) = lhs, case .event1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event2, .event2): return {
        guard case .event2(let l) = lhs, case .event2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event4, .event4): return {
        guard case .event4(let l) = lhs, case .event4(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var common: EventCommon {
    get {return _common ?? EventCommon()}
    set {_common = newValue}
  }
  /// Returns true if `common` has been explicitly set.
  public var hasCommon: Bool {return self._common != nil}
  /// Clears the value of `common`. Subsequent reads from it will return its default value.
  public mutating func clearCommon() {self._common = nil}

  public var header: EventHeader {
    get {return _header ?? EventHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var payload: EventPayload {
    get {return _payload ?? EventPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _common: EventCommon? = nil
  fileprivate var _header: EventHeader? = nil
  fileprivate var _payload: EventPayload? = nil
}

public struct BatchCommon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var instanceID: String = String()

  public var batchID: String = String()

  public var countryCode: String = String()

  public var locale: String = String()

  public var utcOffset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Batch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var common: BatchCommon {
    get {return _common ?? BatchCommon()}
    set {_common = newValue}
  }
  /// Returns true if `common` has been explicitly set.
  public var hasCommon: Bool {return self._common != nil}
  /// Clears the value of `common`. Subsequent reads from it will return its default value.
  public mutating func clearCommon() {self._common = nil}

  public var context: Context {
    get {return _context ?? Context()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var events: [Event] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _common: BatchCommon? = nil
  fileprivate var _context: Context? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ContextApplication: @unchecked Sendable {}
extension ContextDevice: @unchecked Sendable {}
extension Context: @unchecked Sendable {}
extension EventHeaderPora: @unchecked Sendable {}
extension EventHeader: @unchecked Sendable {}
extension EventPayloadPageOpen: @unchecked Sendable {}
extension EventPayloadStarPress: @unchecked Sendable {}
extension EventPayloadScanProcessingStarted: @unchecked Sendable {}
extension EventCommon: @unchecked Sendable {}
extension EventPayload: @unchecked Sendable {}
extension EventPayload.OneOf_EventType: @unchecked Sendable {}
extension Event: @unchecked Sendable {}
extension BatchCommon: @unchecked Sendable {}
extension Batch: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ContextApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContextApplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "app_version"),
    3: .standard(proto: "app_platform"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appPlatform) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 2)
    }
    if !self.appPlatform.isEmpty {
      try visitor.visitSingularStringField(value: self.appPlatform, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ContextApplication, rhs: ContextApplication) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.appPlatform != rhs.appPlatform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ContextDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContextDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_brand"),
    2: .standard(proto: "device_model"),
    3: .standard(proto: "device_carrier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceBrand) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceCarrier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceBrand.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceBrand, fieldNumber: 1)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 2)
    }
    if !self.deviceCarrier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceCarrier, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ContextDevice, rhs: ContextDevice) -> Bool {
    if lhs.deviceBrand != rhs.deviceBrand {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.deviceCarrier != rhs.deviceCarrier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Context: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Context"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "application"),
    2: .same(proto: "device"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._application) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._application {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Context, rhs: Context) -> Bool {
    if lhs._application != rhs._application {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventHeaderPora: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventHeaderPora"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "design_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.designID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.designID.isEmpty {
      try visitor.visitSingularStringField(value: self.designID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventHeaderPora, rhs: EventHeaderPora) -> Bool {
    if lhs.designID != rhs.designID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "pora"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pora) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pora {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventHeader, rhs: EventHeader) -> Bool {
    if lhs._pora != rhs._pora {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventPayloadPageOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventPayloadPageOpen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_id"),
    2: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageID.isEmpty {
      try visitor.visitSingularStringField(value: self.pageID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventPayloadPageOpen, rhs: EventPayloadPageOpen) -> Bool {
    if lhs.pageID != rhs.pageID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventPayloadStarPress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventPayloadStarPress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != 0 {
      try visitor.visitSingularInt64Field(value: self.rate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventPayloadStarPress, rhs: EventPayloadStarPress) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventPayloadScanProcessingStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventPayloadScanProcessingStarted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventPayloadScanProcessingStarted, rhs: EventPayloadScanProcessingStarted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventCommon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventCommon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .standard(proto: "event_ts"),
    3: .standard(proto: "session_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.eventTs) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != 0 {
      try visitor.visitSingularInt64Field(value: self.eventType, fieldNumber: 1)
    }
    if self.eventTs != 0 {
      try visitor.visitSingularInt64Field(value: self.eventTs, fieldNumber: 2)
    }
    if self.sessionID != 0 {
      try visitor.visitSingularInt64Field(value: self.sessionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventCommon, rhs: EventCommon) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.eventTs != rhs.eventTs {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_1"),
    2: .standard(proto: "event_2"),
    4: .standard(proto: "event_4"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventPayloadPageOpen?
        var hadOneofValue = false
        if let current = self.eventType {
          hadOneofValue = true
          if case .event1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventType = .event1(v)
        }
      }()
      case 2: try {
        var v: EventPayloadStarPress?
        var hadOneofValue = false
        if let current = self.eventType {
          hadOneofValue = true
          if case .event2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventType = .event2(v)
        }
      }()
      case 4: try {
        var v: EventPayloadScanProcessingStarted?
        var hadOneofValue = false
        if let current = self.eventType {
          hadOneofValue = true
          if case .event4(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventType = .event4(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.eventType {
    case .event1?: try {
      guard case .event1(let v)? = self.eventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .event2?: try {
      guard case .event2(let v)? = self.eventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .event4?: try {
      guard case .event4(let v)? = self.eventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventPayload, rhs: EventPayload) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "common"),
    2: .same(proto: "header"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._common) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._common {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event, rhs: Event) -> Bool {
    if lhs._common != rhs._common {return false}
    if lhs._header != rhs._header {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BatchCommon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BatchCommon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_id"),
    2: .standard(proto: "batch_id"),
    3: .standard(proto: "country_code"),
    4: .same(proto: "locale"),
    5: .standard(proto: "utc_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 5: try { try decoder.decodeSingularSInt64Field(value: &self.utcOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 1)
    }
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 2)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 3)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 4)
    }
    if self.utcOffset != 0 {
      try visitor.visitSingularSInt64Field(value: self.utcOffset, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BatchCommon, rhs: BatchCommon) -> Bool {
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.batchID != rhs.batchID {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs.utcOffset != rhs.utcOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Batch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Batch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "common"),
    2: .same(proto: "context"),
    3: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._common) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._common {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Batch, rhs: Batch) -> Bool {
    if lhs._common != rhs._common {return false}
    if lhs._context != rhs._context {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
